import { isValidationError, throwValidationError } from "@faremeter/types";
import { createTransferCheckedInstruction, getAssociatedTokenAddressSync, getMint, } from "@solana/spl-token";
import { getBase64EncodedWireTransaction, } from "@solana/transactions";
import { ComputeBudgetProgram, Connection, PublicKey, TransactionInstruction, TransactionMessage, VersionedTransaction, } from "@solana/web3.js";
import { PaymentRequirementsExtra } from "./facilitator.js";
import { generateMatcher } from "./common.js";
export function createPaymentHandler(wallet, mint, connection) {
    const { matchTupleAndAsset } = generateMatcher(wallet.network, mint ? mint.toBase58() : "sol");
    return async (context, accepts) => {
        const res = accepts
            .filter((r) => !isValidationError(matchTupleAndAsset(r)))
            .map((requirements) => {
            const extra = PaymentRequirementsExtra(requirements.extra);
            if (isValidationError(extra)) {
                throwValidationError("couldn't validate requirements extra field", extra);
            }
            const exec = async () => {
                let recentBlockhash;
                if (extra.recentBlockhash !== undefined) {
                    recentBlockhash = extra.recentBlockhash;
                }
                else if (connection !== undefined) {
                    recentBlockhash = (await connection.getLatestBlockhash()).blockhash;
                }
                else {
                    throw new Error("couldn't get the latest Solana network block hash");
                }
                let decimals;
                if (extra.decimals !== undefined) {
                    decimals = extra.decimals;
                }
                else if (connection !== undefined) {
                    const mintInfo = await getMint(connection, mint);
                    decimals = mintInfo.decimals;
                }
                else {
                    throw new Error("couldn't get the decimal information for the mint");
                }
                const paymentRequirements = {
                    ...extra,
                    amount: Number(requirements.maxAmountRequired),
                    receiver: new PublicKey(requirements.payTo),
                };
                const sourceAccount = getAssociatedTokenAddressSync(mint, wallet.publicKey);
                const receiverAccount = getAssociatedTokenAddressSync(mint, paymentRequirements.receiver);
                const instructions = [
                    ComputeBudgetProgram.setComputeUnitLimit({
                        units: 50_000,
                    }),
                    ComputeBudgetProgram.setComputeUnitPrice({
                        microLamports: 1,
                    }),
                    createTransferCheckedInstruction(sourceAccount, mint, receiverAccount, wallet.publicKey, paymentRequirements.amount, decimals),
                ];
                let tx;
                if (wallet.buildTransaction) {
                    tx = await wallet.buildTransaction(instructions, recentBlockhash);
                }
                else {
                    const message = new TransactionMessage({
                        instructions,
                        payerKey: new PublicKey(paymentRequirements.feePayer),
                        recentBlockhash,
                    }).compileToV0Message();
                    tx = new VersionedTransaction(message);
                }
                if (wallet.updateTransaction) {
                    tx = await wallet.updateTransaction(tx);
                }
                const base64EncodedWireTransaction = getBase64EncodedWireTransaction({
                    messageBytes: tx.message.serialize(),
                    signatures: tx.signatures,
                });
                const payload = {
                    transaction: base64EncodedWireTransaction,
                };
                return { payload };
            };
            return {
                exec,
                requirements,
            };
        });
        return res;
    };
}
