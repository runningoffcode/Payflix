import {} from "@faremeter/types/client";
import { processPaymentRequiredResponse, } from "./internal.js";
export class WrappedFetchError extends Error {
    response;
    constructor(message, response) {
        super(message);
        this.response = response;
    }
}
export function wrap(phase2Fetch, options) {
    return async (input, init = {}) => {
        async function makeRequest() {
            const response = await (options.phase1Fetch ?? phase2Fetch)(input, init);
            if (response.status !== 402) {
                return response;
            }
            const ctx = {
                request: input,
            };
            const { paymentHeader } = await processPaymentRequiredResponse(ctx, await response.json(), options);
            const headers = new Headers(init.headers);
            headers.set("X-PAYMENT", paymentHeader);
            const newInit = {
                ...init,
                headers,
            };
            const secondResponse = await phase2Fetch(input, newInit);
            return secondResponse;
        }
        let attempt = (options.retryCount ?? 2) + 1;
        let backoff = options.initialRetryDelay ?? 100;
        let response;
        do {
            response = await makeRequest();
            if (response.status != 402) {
                return response;
            }
            await new Promise((resolve) => setTimeout(resolve, backoff));
            backoff *= 2;
        } while (--attempt > 0);
        if (options.returnPaymentFailure) {
            return response;
        }
        throw new WrappedFetchError("failed to complete payment after retries", response);
    };
}
