const require_level = require('./level.cjs');

//#region logger.ts
/**
* Get a logger with the given category.
*
* ```typescript
* const logger = getLogger(["my-app"]);
* ```
*
* @param category The category of the logger.  It can be a string or an array
*                 of strings.  If it is a string, it is equivalent to an array
*                 with a single element.
* @returns The logger.
*/
function getLogger(category = []) {
	return LoggerImpl.getLogger(category);
}
/**
* The symbol for the global root logger.
*/
const globalRootLoggerSymbol = Symbol.for("logtape.rootLogger");
/**
* A logger implementation.  Do not use this directly; use {@link getLogger}
* instead.  This class is exported for testing purposes.
*/
var LoggerImpl = class LoggerImpl {
	parent;
	children;
	category;
	sinks;
	parentSinks = "inherit";
	filters;
	lowestLevel = "trace";
	contextLocalStorage;
	static getLogger(category = []) {
		let rootLogger = globalRootLoggerSymbol in globalThis ? globalThis[globalRootLoggerSymbol] ?? null : null;
		if (rootLogger == null) {
			rootLogger = new LoggerImpl(null, []);
			globalThis[globalRootLoggerSymbol] = rootLogger;
		}
		if (typeof category === "string") return rootLogger.getChild(category);
		if (category.length === 0) return rootLogger;
		return rootLogger.getChild(category);
	}
	constructor(parent, category) {
		this.parent = parent;
		this.children = {};
		this.category = category;
		this.sinks = [];
		this.filters = [];
	}
	getChild(subcategory) {
		const name = typeof subcategory === "string" ? subcategory : subcategory[0];
		const childRef = this.children[name];
		let child = childRef instanceof LoggerImpl ? childRef : childRef?.deref();
		if (child == null) {
			child = new LoggerImpl(this, [...this.category, name]);
			this.children[name] = "WeakRef" in globalThis ? new WeakRef(child) : child;
		}
		if (typeof subcategory === "string" || subcategory.length === 1) return child;
		return child.getChild(subcategory.slice(1));
	}
	/**
	* Reset the logger.  This removes all sinks and filters from the logger.
	*/
	reset() {
		while (this.sinks.length > 0) this.sinks.shift();
		this.parentSinks = "inherit";
		while (this.filters.length > 0) this.filters.shift();
		this.lowestLevel = "trace";
	}
	/**
	* Reset the logger and all its descendants.  This removes all sinks and
	* filters from the logger and all its descendants.
	*/
	resetDescendants() {
		for (const child of Object.values(this.children)) {
			const logger = child instanceof LoggerImpl ? child : child.deref();
			if (logger != null) logger.resetDescendants();
		}
		this.reset();
	}
	with(properties) {
		return new LoggerCtx(this, { ...properties });
	}
	filter(record) {
		for (const filter of this.filters) if (!filter(record)) return false;
		if (this.filters.length < 1) return this.parent?.filter(record) ?? true;
		return true;
	}
	*getSinks(level) {
		if (this.lowestLevel === null || require_level.compareLogLevel(level, this.lowestLevel) < 0) return;
		if (this.parent != null && this.parentSinks === "inherit") for (const sink of this.parent.getSinks(level)) yield sink;
		for (const sink of this.sinks) yield sink;
	}
	emit(record, bypassSinks) {
		if (this.lowestLevel === null || require_level.compareLogLevel(record.level, this.lowestLevel) < 0 || !this.filter(record)) return;
		for (const sink of this.getSinks(record.level)) {
			if (bypassSinks?.has(sink)) continue;
			try {
				sink(record);
			} catch (error) {
				const bypassSinks2 = new Set(bypassSinks);
				bypassSinks2.add(sink);
				metaLogger.log("fatal", "Failed to emit a log record to sink {sink}: {error}", {
					sink,
					error,
					record
				}, bypassSinks2);
			}
		}
	}
	log(level, rawMessage, properties, bypassSinks) {
		const implicitContext = LoggerImpl.getLogger().contextLocalStorage?.getStore() ?? {};
		let cachedProps = void 0;
		const record = typeof properties === "function" ? {
			category: this.category,
			level,
			timestamp: Date.now(),
			get message() {
				return parseMessageTemplate(rawMessage, this.properties);
			},
			rawMessage,
			get properties() {
				if (cachedProps == null) cachedProps = {
					...implicitContext,
					...properties()
				};
				return cachedProps;
			}
		} : {
			category: this.category,
			level,
			timestamp: Date.now(),
			message: parseMessageTemplate(rawMessage, {
				...implicitContext,
				...properties
			}),
			rawMessage,
			properties: {
				...implicitContext,
				...properties
			}
		};
		this.emit(record, bypassSinks);
	}
	logLazily(level, callback, properties = {}) {
		const implicitContext = LoggerImpl.getLogger().contextLocalStorage?.getStore() ?? {};
		let rawMessage = void 0;
		let msg = void 0;
		function realizeMessage() {
			if (msg == null || rawMessage == null) {
				msg = callback((tpl, ...values) => {
					rawMessage = tpl;
					return renderMessage(tpl, values);
				});
				if (rawMessage == null) throw new TypeError("No log record was made.");
			}
			return [msg, rawMessage];
		}
		this.emit({
			category: this.category,
			level,
			get message() {
				return realizeMessage()[0];
			},
			get rawMessage() {
				return realizeMessage()[1];
			},
			timestamp: Date.now(),
			properties: {
				...implicitContext,
				...properties
			}
		});
	}
	logTemplate(level, messageTemplate, values, properties = {}) {
		const implicitContext = LoggerImpl.getLogger().contextLocalStorage?.getStore() ?? {};
		this.emit({
			category: this.category,
			level,
			message: renderMessage(messageTemplate, values),
			rawMessage: messageTemplate,
			timestamp: Date.now(),
			properties: {
				...implicitContext,
				...properties
			}
		});
	}
	trace(message, ...values) {
		if (typeof message === "string") this.log("trace", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("trace", message);
		else if (!Array.isArray(message)) this.log("trace", "{*}", message);
		else this.logTemplate("trace", message, values);
	}
	debug(message, ...values) {
		if (typeof message === "string") this.log("debug", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("debug", message);
		else if (!Array.isArray(message)) this.log("debug", "{*}", message);
		else this.logTemplate("debug", message, values);
	}
	info(message, ...values) {
		if (typeof message === "string") this.log("info", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("info", message);
		else if (!Array.isArray(message)) this.log("info", "{*}", message);
		else this.logTemplate("info", message, values);
	}
	warn(message, ...values) {
		if (typeof message === "string") this.log("warning", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("warning", message);
		else if (!Array.isArray(message)) this.log("warning", "{*}", message);
		else this.logTemplate("warning", message, values);
	}
	warning(message, ...values) {
		this.warn(message, ...values);
	}
	error(message, ...values) {
		if (typeof message === "string") this.log("error", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("error", message);
		else if (!Array.isArray(message)) this.log("error", "{*}", message);
		else this.logTemplate("error", message, values);
	}
	fatal(message, ...values) {
		if (typeof message === "string") this.log("fatal", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("fatal", message);
		else if (!Array.isArray(message)) this.log("fatal", "{*}", message);
		else this.logTemplate("fatal", message, values);
	}
};
/**
* A logger implementation with contextual properties.  Do not use this
* directly; use {@link Logger.with} instead.  This class is exported
* for testing purposes.
*/
var LoggerCtx = class LoggerCtx {
	logger;
	properties;
	constructor(logger, properties) {
		this.logger = logger;
		this.properties = properties;
	}
	get category() {
		return this.logger.category;
	}
	get parent() {
		return this.logger.parent;
	}
	getChild(subcategory) {
		return this.logger.getChild(subcategory).with(this.properties);
	}
	with(properties) {
		return new LoggerCtx(this.logger, {
			...this.properties,
			...properties
		});
	}
	log(level, message, properties, bypassSinks) {
		this.logger.log(level, message, typeof properties === "function" ? () => ({
			...this.properties,
			...properties()
		}) : {
			...this.properties,
			...properties
		}, bypassSinks);
	}
	logLazily(level, callback) {
		this.logger.logLazily(level, callback, this.properties);
	}
	logTemplate(level, messageTemplate, values) {
		this.logger.logTemplate(level, messageTemplate, values, this.properties);
	}
	trace(message, ...values) {
		if (typeof message === "string") this.log("trace", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("trace", message);
		else if (!Array.isArray(message)) this.log("trace", "{*}", message);
		else this.logTemplate("trace", message, values);
	}
	debug(message, ...values) {
		if (typeof message === "string") this.log("debug", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("debug", message);
		else if (!Array.isArray(message)) this.log("debug", "{*}", message);
		else this.logTemplate("debug", message, values);
	}
	info(message, ...values) {
		if (typeof message === "string") this.log("info", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("info", message);
		else if (!Array.isArray(message)) this.log("info", "{*}", message);
		else this.logTemplate("info", message, values);
	}
	warn(message, ...values) {
		if (typeof message === "string") this.log("warning", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("warning", message);
		else if (!Array.isArray(message)) this.log("warning", "{*}", message);
		else this.logTemplate("warning", message, values);
	}
	warning(message, ...values) {
		this.warn(message, ...values);
	}
	error(message, ...values) {
		if (typeof message === "string") this.log("error", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("error", message);
		else if (!Array.isArray(message)) this.log("error", "{*}", message);
		else this.logTemplate("error", message, values);
	}
	fatal(message, ...values) {
		if (typeof message === "string") this.log("fatal", message, values[0] ?? {});
		else if (typeof message === "function") this.logLazily("fatal", message);
		else if (!Array.isArray(message)) this.log("fatal", "{*}", message);
		else this.logTemplate("fatal", message, values);
	}
};
/**
* The meta logger.  It is a logger with the category `["logtape", "meta"]`.
*/
const metaLogger = LoggerImpl.getLogger(["logtape", "meta"]);
/**
* Parse a message template into a message template array and a values array.
* @param template The message template.
* @param properties The values to replace placeholders with.
* @returns The message template array and the values array.
*/
function parseMessageTemplate(template, properties) {
	const length = template.length;
	if (length === 0) return [""];
	if (!template.includes("{")) return [template];
	const message = [];
	let startIndex = 0;
	for (let i = 0; i < length; i++) {
		const char = template[i];
		if (char === "{") {
			const nextChar = i + 1 < length ? template[i + 1] : "";
			if (nextChar === "{") {
				i++;
				continue;
			}
			const closeIndex = template.indexOf("}", i + 1);
			if (closeIndex === -1) continue;
			const beforeText = template.slice(startIndex, i);
			message.push(beforeText.replace(/{{/g, "{").replace(/}}/g, "}"));
			const key = template.slice(i + 1, closeIndex);
			let prop;
			const trimmedKey = key.trim();
			if (trimmedKey === "*") prop = key in properties ? properties[key] : "*" in properties ? properties["*"] : properties;
			else if (key !== trimmedKey) prop = key in properties ? properties[key] : properties[trimmedKey];
			else prop = properties[key];
			message.push(prop);
			i = closeIndex;
			startIndex = i + 1;
		} else if (char === "}" && i + 1 < length && template[i + 1] === "}") i++;
	}
	const remainingText = template.slice(startIndex);
	message.push(remainingText.replace(/{{/g, "{").replace(/}}/g, "}"));
	return message;
}
/**
* Render a message template with values.
* @param template The message template.
* @param values The message template values.
* @returns The message template values interleaved between the substitution
*          values.
*/
function renderMessage(template, values) {
	const args = [];
	for (let i = 0; i < template.length; i++) {
		args.push(template[i]);
		if (i < values.length) args.push(values[i]);
	}
	return args;
}

//#endregion
exports.LoggerImpl = LoggerImpl;
exports.getLogger = getLogger;